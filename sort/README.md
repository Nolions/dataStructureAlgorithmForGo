# Sort 排序

## 氣泡排序

從第一個元素開始與相鄰的元素進行比較，如果排序有錯則兩個數進行對調

架設要把陣列[8, 4, 3, 0]進行排序，其過程大概如下：

```
# 第一輪
[8, 4, 3, 0] 
[4, 8, 3, 0] 
[4, 3, 8, 0] 
[4, 3, 0, 8]
# 第二輪
[3, 4, 0, 8] 
[3, 0, 4, 8]
[3, 0, 4, 8]
# 第三輪
[0, 3, 4, 8]
[0, 3, 4, 8]
```

透過雙層迴圈方式來實作

```go
for i := 0; i < len(data)-1; i++ {
    for j := 0; j < len(data)-i-1; j++ {
        // TODO
    }
}
```

比較的兩個元素排序如果有錯則進行對調

```go
if data[j] > data[j+1] {
	temp := data[j]
	data[j] = data[j+1]
    data[j+1] = temp
}
```

也可以用golang中獨有更簡潔的寫法，就不須再需告一個變數作為暫時儲存用

```go
if data[j] > data[j+1] {
	data[j], data[j+1] = data[j+1], data[j]
}
```

時間複雜度: $O(n^2$)

## 選擇排序

將陣列區分成未排序與已排序兩這陣列，然後從未陣列中找出最小(大)的值，並且把該值加入倒已經排序中陣列最後。最後遍歷過所有未排序陣列就可以完成排序。

```
# 原始陣列，最小值: 0
[8, 4, 3, 0]  

# 第一輪
## 已排序
[0]
## 未排序，最小值: 3
[8, 4, 3]

# 第二輪
## 已排序
[0, 3]
## 未排序，最小值: 4
[8, 4]

# 第三輪 
## 已排序
[0, 3, 4]
## 未排序，最小值: 8
[8]

# 第三輪
## 已排序
[0, 3, 4, 8]
```

透過雙層迴圈方式分別找出每一輪陣列中的最小值所在位置

```go
for i := 0; i < len(data)-1; i++ {
    minIndex := i // 紀錄陣列中最小值索引
    for j := i + 1; j < len(data); j++ {
        if data[minIndex] > data[j] {
            minIndex = j
        }
    }
}
```

時間複雜度: $O(n^2$)

## 插入排序

從陣列中取得i值，並且與i-1值進行排序，如果該i值較小則往前移，並繼續與下一位置值近進行比較，但如果i值較大，則進到下一輪，並重複之前的步驟。

```
# 原始陣列
[8, 4, 3, 0]

# 第一輪，i值:4，並且與之前的值逐一比對，如果i值較小則往前移一位
[4, 8, 3, 0] // 4 < 8，4往前移

# 第二輪，i:2、值:3
[4, 3, 8, 0] // 3 < 8，3往前移
[3, 4, 8, 0] // 3 < 4，3往前移

# 第三輪，i:2、值:0
[3, 4, 0, 8] // 0 < 8，0往前移
[3, 0, 4, 8] // 0 < 4，0往前移
[0, 3, 4, 8] // 0 < 3，0往前移
```

時間複雜度: $O(n^2$)