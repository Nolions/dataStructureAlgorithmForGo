# Sort 排序

## 氣泡排序

從第一個元素開始與相鄰的元素進行比較，如果排序有錯則兩個數進行對調

架設要把陣列[8, 4, 3, 0]進行排序，其過程大概如下：

```
# 第一輪
[8, 4, 3, 0] 
[4, 8, 3, 0] 
[4, 3, 8, 0] 
[4, 3, 0, 8]
# 第二輪
[3, 4, 0, 8] 
[3, 0, 4, 8]
[3, 0, 4, 8]
# 第三輪
[0, 3, 4, 8]
[0, 3, 4, 8]
```

透過雙層迴圈方式來實作

```go
for i := 0; i < len(data)-1; i++ {
    for j := 0; j < len(data)-i-1; j++ {
        // TODO
    }
}
```

比較的兩個元素排序如果有錯則進行對調

```go
if data[j] > data[j+1] {
	temp := data[j]
	data[j] = data[j+1]
    data[j+1] = temp
}
```

也可以用golang中獨有更簡潔的寫法，就不須再需告一個變數作為暫時儲存用

```go
if data[j] > data[j+1] {
	data[j], data[j+1] = data[j+1], data[j]
}
```

時間複雜度: $O(n^2$)

## 選擇排序

將陣列區分成未排序與已排序兩這陣列，然後從未陣列中找出最小(大)的值，並且把該值加入倒已經排序中陣列最後。最後遍歷過所有未排序陣列就可以完成排序。

```
# 原始陣列 
[8, 4, 3, 0]  

# 第一輪
## 已排序
[0]
## 未排序
[8, 4, 3]

# 第二輪
## 已排序
[0, 3]
## 未排序
[8, 4]


# 第二輪
## 已排序
[0, 3, 4]
## 未排序
[8]

# 第三輪
## 已排序
[0, 3, 4, 8]
```

找出陣列中的最小值

```go
for i := 0; i < len(data)-1; i++ {
    minIndex := i // 紀錄陣列中最小值索引
    for j := i + 1; j < len(data); j++ {
        if data[minIndex] > data[j] {
            minIndex = j
        }
    }
}
```

時間複雜度: $O(n^2$)

## 快速排序

時間複雜度: $O(n^2$)